// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sogou/speech/asr/v1/asr.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "sogou/speech/asr/v1/Asr.pbobjc.h"
#import "google/rpc/Status.pbobjc.h"
#import "sogou/speech/longrunning/Operations.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"

#pragma mark - SPBAsrRoot

@implementation SPBAsrRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - SPBAsrRoot_FileDescriptor

static GPBFileDescriptor *SPBAsrRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"sogou.speech.asr.v1"
                                                 objcPrefix:@"SPB"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - SPBRecognizeRequest

@implementation SPBRecognizeRequest

@dynamic hasConfig, config;
@dynamic hasAudio, audio;

typedef struct SPBRecognizeRequest__storage_ {
  uint32_t _has_storage_[1];
  SPBRecognitionConfig *config;
  SPBRecognitionAudio *audio;
} SPBRecognizeRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "config",
        .dataTypeSpecific.className = GPBStringifySymbol(SPBRecognitionConfig),
        .number = SPBRecognizeRequest_FieldNumber_Config,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SPBRecognizeRequest__storage_, config),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "audio",
        .dataTypeSpecific.className = GPBStringifySymbol(SPBRecognitionAudio),
        .number = SPBRecognizeRequest_FieldNumber_Audio,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SPBRecognizeRequest__storage_, audio),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SPBRecognizeRequest class]
                                     rootClass:[SPBAsrRoot class]
                                          file:SPBAsrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SPBRecognizeRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SPBLongRunningRecognizeRequest

@implementation SPBLongRunningRecognizeRequest

@dynamic hasConfig, config;
@dynamic hasAudio, audio;

typedef struct SPBLongRunningRecognizeRequest__storage_ {
  uint32_t _has_storage_[1];
  SPBRecognitionConfig *config;
  SPBRecognitionAudio *audio;
} SPBLongRunningRecognizeRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "config",
        .dataTypeSpecific.className = GPBStringifySymbol(SPBRecognitionConfig),
        .number = SPBLongRunningRecognizeRequest_FieldNumber_Config,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SPBLongRunningRecognizeRequest__storage_, config),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "audio",
        .dataTypeSpecific.className = GPBStringifySymbol(SPBRecognitionAudio),
        .number = SPBLongRunningRecognizeRequest_FieldNumber_Audio,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SPBLongRunningRecognizeRequest__storage_, audio),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SPBLongRunningRecognizeRequest class]
                                     rootClass:[SPBAsrRoot class]
                                          file:SPBAsrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SPBLongRunningRecognizeRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SPBStreamingRecognizeRequest

@implementation SPBStreamingRecognizeRequest

@dynamic streamingRequestOneOfCase;
@dynamic streamingConfig;
@dynamic audioContent;

typedef struct SPBStreamingRecognizeRequest__storage_ {
  uint32_t _has_storage_[2];
  SPBStreamingRecognitionConfig *streamingConfig;
  NSData *audioContent;
} SPBStreamingRecognizeRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "streamingConfig",
        .dataTypeSpecific.className = GPBStringifySymbol(SPBStreamingRecognitionConfig),
        .number = SPBStreamingRecognizeRequest_FieldNumber_StreamingConfig,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SPBStreamingRecognizeRequest__storage_, streamingConfig),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "audioContent",
        .dataTypeSpecific.className = NULL,
        .number = SPBStreamingRecognizeRequest_FieldNumber_AudioContent,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SPBStreamingRecognizeRequest__storage_, audioContent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SPBStreamingRecognizeRequest class]
                                     rootClass:[SPBAsrRoot class]
                                          file:SPBAsrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SPBStreamingRecognizeRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "streamingRequest",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void SPBStreamingRecognizeRequest_ClearStreamingRequestOneOfCase(SPBStreamingRecognizeRequest *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - SPBStreamingRecognitionConfig

@implementation SPBStreamingRecognitionConfig

@dynamic hasConfig, config;
@dynamic singleUtterance;
@dynamic interimResults;
@dynamic enableInterimResultsPunctuation;
@dynamic mergeUtterance;

typedef struct SPBStreamingRecognitionConfig__storage_ {
  uint32_t _has_storage_[1];
  SPBRecognitionConfig *config;
} SPBStreamingRecognitionConfig__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "config",
        .dataTypeSpecific.className = GPBStringifySymbol(SPBRecognitionConfig),
        .number = SPBStreamingRecognitionConfig_FieldNumber_Config,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SPBStreamingRecognitionConfig__storage_, config),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "singleUtterance",
        .dataTypeSpecific.className = NULL,
        .number = SPBStreamingRecognitionConfig_FieldNumber_SingleUtterance,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "interimResults",
        .dataTypeSpecific.className = NULL,
        .number = SPBStreamingRecognitionConfig_FieldNumber_InterimResults,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "enableInterimResultsPunctuation",
        .dataTypeSpecific.className = NULL,
        .number = SPBStreamingRecognitionConfig_FieldNumber_EnableInterimResultsPunctuation,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "mergeUtterance",
        .dataTypeSpecific.className = NULL,
        .number = SPBStreamingRecognitionConfig_FieldNumber_MergeUtterance,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SPBStreamingRecognitionConfig class]
                                     rootClass:[SPBAsrRoot class]
                                          file:SPBAsrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SPBStreamingRecognitionConfig__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SPBRecognitionConfig

@implementation SPBRecognitionConfig

@dynamic encoding;
@dynamic sampleRateHertz;
@dynamic languageCode;
@dynamic maxAlternatives;
@dynamic profanityFilter;
@dynamic speechContextsArray, speechContextsArray_Count;
@dynamic enableWordTimeOffsets;
@dynamic disableAutomaticPunctuation;
@dynamic model;
@dynamic extraConfigsArray, extraConfigsArray_Count;

typedef struct SPBRecognitionConfig__storage_ {
  uint32_t _has_storage_[1];
  SPBRecognitionConfig_AudioEncoding encoding;
  int32_t sampleRateHertz;
  int32_t maxAlternatives;
  NSString *languageCode;
  NSMutableArray *speechContextsArray;
  NSString *model;
  NSMutableArray *extraConfigsArray;
} SPBRecognitionConfig__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "encoding",
        .dataTypeSpecific.enumDescFunc = SPBRecognitionConfig_AudioEncoding_EnumDescriptor,
        .number = SPBRecognitionConfig_FieldNumber_Encoding,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SPBRecognitionConfig__storage_, encoding),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "sampleRateHertz",
        .dataTypeSpecific.className = NULL,
        .number = SPBRecognitionConfig_FieldNumber_SampleRateHertz,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SPBRecognitionConfig__storage_, sampleRateHertz),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "languageCode",
        .dataTypeSpecific.className = NULL,
        .number = SPBRecognitionConfig_FieldNumber_LanguageCode,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SPBRecognitionConfig__storage_, languageCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "maxAlternatives",
        .dataTypeSpecific.className = NULL,
        .number = SPBRecognitionConfig_FieldNumber_MaxAlternatives,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SPBRecognitionConfig__storage_, maxAlternatives),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "profanityFilter",
        .dataTypeSpecific.className = NULL,
        .number = SPBRecognitionConfig_FieldNumber_ProfanityFilter,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "speechContextsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(SPBSpeechContext),
        .number = SPBRecognitionConfig_FieldNumber_SpeechContextsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SPBRecognitionConfig__storage_, speechContextsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "enableWordTimeOffsets",
        .dataTypeSpecific.className = NULL,
        .number = SPBRecognitionConfig_FieldNumber_EnableWordTimeOffsets,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "disableAutomaticPunctuation",
        .dataTypeSpecific.className = NULL,
        .number = SPBRecognitionConfig_FieldNumber_DisableAutomaticPunctuation,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "model",
        .dataTypeSpecific.className = NULL,
        .number = SPBRecognitionConfig_FieldNumber_Model,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(SPBRecognitionConfig__storage_, model),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "extraConfigsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBAny),
        .number = SPBRecognitionConfig_FieldNumber_ExtraConfigsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SPBRecognitionConfig__storage_, extraConfigsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SPBRecognitionConfig class]
                                     rootClass:[SPBAsrRoot class]
                                          file:SPBAsrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SPBRecognitionConfig__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t SPBRecognitionConfig_Encoding_RawValue(SPBRecognitionConfig *message) {
  GPBDescriptor *descriptor = [SPBRecognitionConfig descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SPBRecognitionConfig_FieldNumber_Encoding];
  return GPBGetMessageInt32Field(message, field);
}

void SetSPBRecognitionConfig_Encoding_RawValue(SPBRecognitionConfig *message, int32_t value) {
  GPBDescriptor *descriptor = [SPBRecognitionConfig descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SPBRecognitionConfig_FieldNumber_Encoding];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum SPBRecognitionConfig_AudioEncoding

GPBEnumDescriptor *SPBRecognitionConfig_AudioEncoding_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "EncodingUnspecified\000Linear16\000Flac\000SogouS"
        "peex\000";
    static const int32_t values[] = {
        SPBRecognitionConfig_AudioEncoding_EncodingUnspecified,
        SPBRecognitionConfig_AudioEncoding_Linear16,
        SPBRecognitionConfig_AudioEncoding_Flac,
        SPBRecognitionConfig_AudioEncoding_SogouSpeex,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SPBRecognitionConfig_AudioEncoding)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SPBRecognitionConfig_AudioEncoding_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SPBRecognitionConfig_AudioEncoding_IsValidValue(int32_t value__) {
  switch (value__) {
    case SPBRecognitionConfig_AudioEncoding_EncodingUnspecified:
    case SPBRecognitionConfig_AudioEncoding_Linear16:
    case SPBRecognitionConfig_AudioEncoding_Flac:
    case SPBRecognitionConfig_AudioEncoding_SogouSpeex:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - SPBSpeechContext

@implementation SPBSpeechContext

@dynamic phrasesArray, phrasesArray_Count;

typedef struct SPBSpeechContext__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *phrasesArray;
} SPBSpeechContext__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "phrasesArray",
        .dataTypeSpecific.className = NULL,
        .number = SPBSpeechContext_FieldNumber_PhrasesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SPBSpeechContext__storage_, phrasesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SPBSpeechContext class]
                                     rootClass:[SPBAsrRoot class]
                                          file:SPBAsrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SPBSpeechContext__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SPBRecognitionAudio

@implementation SPBRecognitionAudio

@dynamic audioSourceOneOfCase;
@dynamic content;
@dynamic uri;

typedef struct SPBRecognitionAudio__storage_ {
  uint32_t _has_storage_[2];
  NSData *content;
  NSString *uri;
} SPBRecognitionAudio__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = SPBRecognitionAudio_FieldNumber_Content,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SPBRecognitionAudio__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "uri",
        .dataTypeSpecific.className = NULL,
        .number = SPBRecognitionAudio_FieldNumber_Uri,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SPBRecognitionAudio__storage_, uri),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SPBRecognitionAudio class]
                                     rootClass:[SPBAsrRoot class]
                                          file:SPBAsrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SPBRecognitionAudio__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "audioSource",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void SPBRecognitionAudio_ClearAudioSourceOneOfCase(SPBRecognitionAudio *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - SPBRecognizeResponse

@implementation SPBRecognizeResponse

@dynamic resultsArray, resultsArray_Count;

typedef struct SPBRecognizeResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *resultsArray;
} SPBRecognizeResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "resultsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(SPBSpeechRecognitionResult),
        .number = SPBRecognizeResponse_FieldNumber_ResultsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SPBRecognizeResponse__storage_, resultsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SPBRecognizeResponse class]
                                     rootClass:[SPBAsrRoot class]
                                          file:SPBAsrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SPBRecognizeResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SPBLongRunningRecognizeResponse

@implementation SPBLongRunningRecognizeResponse

@dynamic resultsArray, resultsArray_Count;

typedef struct SPBLongRunningRecognizeResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *resultsArray;
} SPBLongRunningRecognizeResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "resultsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(SPBSpeechRecognitionResult),
        .number = SPBLongRunningRecognizeResponse_FieldNumber_ResultsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SPBLongRunningRecognizeResponse__storage_, resultsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SPBLongRunningRecognizeResponse class]
                                     rootClass:[SPBAsrRoot class]
                                          file:SPBAsrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SPBLongRunningRecognizeResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SPBLongRunningRecognizeMetadata

@implementation SPBLongRunningRecognizeMetadata

@dynamic progressPercent;
@dynamic hasStartTime, startTime;
@dynamic hasLastUpdateTime, lastUpdateTime;

typedef struct SPBLongRunningRecognizeMetadata__storage_ {
  uint32_t _has_storage_[1];
  int32_t progressPercent;
  GPBTimestamp *startTime;
  GPBTimestamp *lastUpdateTime;
} SPBLongRunningRecognizeMetadata__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "progressPercent",
        .dataTypeSpecific.className = NULL,
        .number = SPBLongRunningRecognizeMetadata_FieldNumber_ProgressPercent,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SPBLongRunningRecognizeMetadata__storage_, progressPercent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "startTime",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBTimestamp),
        .number = SPBLongRunningRecognizeMetadata_FieldNumber_StartTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SPBLongRunningRecognizeMetadata__storage_, startTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lastUpdateTime",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBTimestamp),
        .number = SPBLongRunningRecognizeMetadata_FieldNumber_LastUpdateTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SPBLongRunningRecognizeMetadata__storage_, lastUpdateTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SPBLongRunningRecognizeMetadata class]
                                     rootClass:[SPBAsrRoot class]
                                          file:SPBAsrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SPBLongRunningRecognizeMetadata__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SPBStreamingRecognizeResponse

@implementation SPBStreamingRecognizeResponse

@dynamic hasError, error;
@dynamic resultsArray, resultsArray_Count;
@dynamic speechEventType;

typedef struct SPBStreamingRecognizeResponse__storage_ {
  uint32_t _has_storage_[1];
  SPBStreamingRecognizeResponse_SpeechEventType speechEventType;
  RPCStatus *error;
  NSMutableArray *resultsArray;
} SPBStreamingRecognizeResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.className = GPBStringifySymbol(RPCStatus),
        .number = SPBStreamingRecognizeResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SPBStreamingRecognizeResponse__storage_, error),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "resultsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(SPBStreamingRecognitionResult),
        .number = SPBStreamingRecognizeResponse_FieldNumber_ResultsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SPBStreamingRecognizeResponse__storage_, resultsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "speechEventType",
        .dataTypeSpecific.enumDescFunc = SPBStreamingRecognizeResponse_SpeechEventType_EnumDescriptor,
        .number = SPBStreamingRecognizeResponse_FieldNumber_SpeechEventType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SPBStreamingRecognizeResponse__storage_, speechEventType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SPBStreamingRecognizeResponse class]
                                     rootClass:[SPBAsrRoot class]
                                          file:SPBAsrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SPBStreamingRecognizeResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t SPBStreamingRecognizeResponse_SpeechEventType_RawValue(SPBStreamingRecognizeResponse *message) {
  GPBDescriptor *descriptor = [SPBStreamingRecognizeResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SPBStreamingRecognizeResponse_FieldNumber_SpeechEventType];
  return GPBGetMessageInt32Field(message, field);
}

void SetSPBStreamingRecognizeResponse_SpeechEventType_RawValue(SPBStreamingRecognizeResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [SPBStreamingRecognizeResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SPBStreamingRecognizeResponse_FieldNumber_SpeechEventType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum SPBStreamingRecognizeResponse_SpeechEventType

GPBEnumDescriptor *SPBStreamingRecognizeResponse_SpeechEventType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "SpeechEventUnspecified\000EndOfSingleUttera"
        "nce\000";
    static const int32_t values[] = {
        SPBStreamingRecognizeResponse_SpeechEventType_SpeechEventUnspecified,
        SPBStreamingRecognizeResponse_SpeechEventType_EndOfSingleUtterance,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SPBStreamingRecognizeResponse_SpeechEventType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SPBStreamingRecognizeResponse_SpeechEventType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SPBStreamingRecognizeResponse_SpeechEventType_IsValidValue(int32_t value__) {
  switch (value__) {
    case SPBStreamingRecognizeResponse_SpeechEventType_SpeechEventUnspecified:
    case SPBStreamingRecognizeResponse_SpeechEventType_EndOfSingleUtterance:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - SPBStreamingRecognitionResult

@implementation SPBStreamingRecognitionResult

@dynamic alternativesArray, alternativesArray_Count;
@dynamic isFinal;
@dynamic stability;
@dynamic extra, extra_Count;

typedef struct SPBStreamingRecognitionResult__storage_ {
  uint32_t _has_storage_[1];
  float stability;
  NSMutableArray *alternativesArray;
  NSMutableDictionary *extra;
} SPBStreamingRecognitionResult__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "alternativesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(SPBSpeechRecognitionAlternative),
        .number = SPBStreamingRecognitionResult_FieldNumber_AlternativesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SPBStreamingRecognitionResult__storage_, alternativesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isFinal",
        .dataTypeSpecific.className = NULL,
        .number = SPBStreamingRecognitionResult_FieldNumber_IsFinal,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "stability",
        .dataTypeSpecific.className = NULL,
        .number = SPBStreamingRecognitionResult_FieldNumber_Stability,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SPBStreamingRecognitionResult__storage_, stability),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "extra",
        .dataTypeSpecific.className = NULL,
        .number = SPBStreamingRecognitionResult_FieldNumber_Extra,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SPBStreamingRecognitionResult__storage_, extra),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SPBStreamingRecognitionResult class]
                                     rootClass:[SPBAsrRoot class]
                                          file:SPBAsrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SPBStreamingRecognitionResult__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SPBSpeechRecognitionResult

@implementation SPBSpeechRecognitionResult

@dynamic alternativesArray, alternativesArray_Count;
@dynamic extra, extra_Count;

typedef struct SPBSpeechRecognitionResult__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *alternativesArray;
  NSMutableDictionary *extra;
} SPBSpeechRecognitionResult__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "alternativesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(SPBSpeechRecognitionAlternative),
        .number = SPBSpeechRecognitionResult_FieldNumber_AlternativesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SPBSpeechRecognitionResult__storage_, alternativesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extra",
        .dataTypeSpecific.className = NULL,
        .number = SPBSpeechRecognitionResult_FieldNumber_Extra,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SPBSpeechRecognitionResult__storage_, extra),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SPBSpeechRecognitionResult class]
                                     rootClass:[SPBAsrRoot class]
                                          file:SPBAsrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SPBSpeechRecognitionResult__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SPBSpeechRecognitionAlternative

@implementation SPBSpeechRecognitionAlternative

@dynamic transcript;
@dynamic confidence;
@dynamic wordsArray, wordsArray_Count;
@dynamic extra, extra_Count;

typedef struct SPBSpeechRecognitionAlternative__storage_ {
  uint32_t _has_storage_[1];
  float confidence;
  NSString *transcript;
  NSMutableArray *wordsArray;
  NSMutableDictionary *extra;
} SPBSpeechRecognitionAlternative__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transcript",
        .dataTypeSpecific.className = NULL,
        .number = SPBSpeechRecognitionAlternative_FieldNumber_Transcript,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SPBSpeechRecognitionAlternative__storage_, transcript),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "confidence",
        .dataTypeSpecific.className = NULL,
        .number = SPBSpeechRecognitionAlternative_FieldNumber_Confidence,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SPBSpeechRecognitionAlternative__storage_, confidence),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "wordsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(SPBWordInfo),
        .number = SPBSpeechRecognitionAlternative_FieldNumber_WordsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SPBSpeechRecognitionAlternative__storage_, wordsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extra",
        .dataTypeSpecific.className = NULL,
        .number = SPBSpeechRecognitionAlternative_FieldNumber_Extra,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SPBSpeechRecognitionAlternative__storage_, extra),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SPBSpeechRecognitionAlternative class]
                                     rootClass:[SPBAsrRoot class]
                                          file:SPBAsrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SPBSpeechRecognitionAlternative__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SPBWordInfo

@implementation SPBWordInfo

@dynamic hasStartTime, startTime;
@dynamic hasEndTime, endTime;
@dynamic word;

typedef struct SPBWordInfo__storage_ {
  uint32_t _has_storage_[1];
  GPBDuration *startTime;
  GPBDuration *endTime;
  NSString *word;
} SPBWordInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "startTime",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBDuration),
        .number = SPBWordInfo_FieldNumber_StartTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SPBWordInfo__storage_, startTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBDuration),
        .number = SPBWordInfo_FieldNumber_EndTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SPBWordInfo__storage_, endTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "word",
        .dataTypeSpecific.className = NULL,
        .number = SPBWordInfo_FieldNumber_Word,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SPBWordInfo__storage_, word),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SPBWordInfo class]
                                     rootClass:[SPBAsrRoot class]
                                          file:SPBAsrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SPBWordInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
